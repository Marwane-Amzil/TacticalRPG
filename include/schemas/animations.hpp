// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ANIMATIONS_H_
#define FLATBUFFERS_GENERATED_ANIMATIONS_H_

#include "flatbuffers/flatbuffers.h"

struct AnimationSetRoot;
struct AnimationSetRootBuilder;

struct AnimationSet;
struct AnimationSetBuilder;

struct Animation;
struct AnimationBuilder;

struct Frame;
struct FrameBuilder;

struct AnimationSetRoot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AnimationSetRootBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SET = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<AnimationSet>> *set() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimationSet>> *>(VT_SET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SET) &&
           verifier.VerifyVector(set()) &&
           verifier.VerifyVectorOfTables(set()) &&
           verifier.EndTable();
  }
};

struct AnimationSetRootBuilder {
  typedef AnimationSetRoot Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_set(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationSet>>> set) {
    fbb_.AddOffset(AnimationSetRoot::VT_SET, set);
  }
  explicit AnimationSetRootBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AnimationSetRoot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimationSetRoot>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimationSetRoot> CreateAnimationSetRoot(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationSet>>> set = 0) {
  AnimationSetRootBuilder builder_(_fbb);
  builder_.add_set(set);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimationSetRoot> CreateAnimationSetRootDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    std::vector<flatbuffers::Offset<AnimationSet>> *set = nullptr) {
  auto set__ = set ? _fbb.CreateVectorOfSortedTables<AnimationSet>(set) : 0;
  return CreateAnimationSetRoot(
      _fbb,
      set__);
}

struct AnimationSet FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AnimationSetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_ANIMATIONS = 6
  };
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  bool KeyCompareLessThan(const AnimationSet *o) const {
    return *type() < *o->type();
  }
  int KeyCompareWithValue(const char *_type) const {
    return strcmp(type()->c_str(), _type);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Animation>> *animations() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Animation>> *>(VT_ANIMATIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_ANIMATIONS) &&
           verifier.VerifyVector(animations()) &&
           verifier.VerifyVectorOfTables(animations()) &&
           verifier.EndTable();
  }
};

struct AnimationSetBuilder {
  typedef AnimationSet Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(AnimationSet::VT_TYPE, type);
  }
  void add_animations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Animation>>> animations) {
    fbb_.AddOffset(AnimationSet::VT_ANIMATIONS, animations);
  }
  explicit AnimationSetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AnimationSet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimationSet>(end);
    fbb_.Required(o, AnimationSet::VT_TYPE);
    return o;
  }
};

inline flatbuffers::Offset<AnimationSet> CreateAnimationSet(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Animation>>> animations = 0) {
  AnimationSetBuilder builder_(_fbb);
  builder_.add_animations(animations);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimationSet> CreateAnimationSetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    const std::vector<flatbuffers::Offset<Animation>> *animations = nullptr) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto animations__ = animations ? _fbb.CreateVector<flatbuffers::Offset<Animation>>(*animations) : 0;
  return CreateAnimationSet(
      _fbb,
      type__,
      animations__);
}

struct Animation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AnimationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_FRAMES = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Frame>> *frames() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Frame>> *>(VT_FRAMES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_FRAMES) &&
           verifier.VerifyVector(frames()) &&
           verifier.VerifyVectorOfTables(frames()) &&
           verifier.EndTable();
  }
};

struct AnimationBuilder {
  typedef Animation Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Animation::VT_NAME, name);
  }
  void add_frames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Frame>>> frames) {
    fbb_.AddOffset(Animation::VT_FRAMES, frames);
  }
  explicit AnimationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Animation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Animation>(end);
    return o;
  }
};

inline flatbuffers::Offset<Animation> CreateAnimation(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Frame>>> frames = 0) {
  AnimationBuilder builder_(_fbb);
  builder_.add_frames(frames);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Animation> CreateAnimationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<Frame>> *frames = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto frames__ = frames ? _fbb.CreateVector<flatbuffers::Offset<Frame>>(*frames) : 0;
  return CreateAnimation(
      _fbb,
      name__,
      frames__);
}

struct Frame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FrameBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEFT = 4,
    VT_TOP = 6,
    VT_WIDTH = 8,
    VT_HEIGHT = 10
  };
  uint32_t left() const {
    return GetField<uint32_t>(VT_LEFT, 0);
  }
  uint32_t top() const {
    return GetField<uint32_t>(VT_TOP, 0);
  }
  uint32_t width() const {
    return GetField<uint32_t>(VT_WIDTH, 0);
  }
  uint32_t height() const {
    return GetField<uint32_t>(VT_HEIGHT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_LEFT, 4) &&
           VerifyField<uint32_t>(verifier, VT_TOP, 4) &&
           VerifyField<uint32_t>(verifier, VT_WIDTH, 4) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT, 4) &&
           verifier.EndTable();
  }
};

struct FrameBuilder {
  typedef Frame Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_left(uint32_t left) {
    fbb_.AddElement<uint32_t>(Frame::VT_LEFT, left, 0);
  }
  void add_top(uint32_t top) {
    fbb_.AddElement<uint32_t>(Frame::VT_TOP, top, 0);
  }
  void add_width(uint32_t width) {
    fbb_.AddElement<uint32_t>(Frame::VT_WIDTH, width, 0);
  }
  void add_height(uint32_t height) {
    fbb_.AddElement<uint32_t>(Frame::VT_HEIGHT, height, 0);
  }
  explicit FrameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Frame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Frame>(end);
    return o;
  }
};

inline flatbuffers::Offset<Frame> CreateFrame(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t left = 0,
    uint32_t top = 0,
    uint32_t width = 0,
    uint32_t height = 0) {
  FrameBuilder builder_(_fbb);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_top(top);
  builder_.add_left(left);
  return builder_.Finish();
}

inline const AnimationSetRoot *GetAnimationSetRoot(const void *buf) {
  return flatbuffers::GetRoot<AnimationSetRoot>(buf);
}

inline const AnimationSetRoot *GetSizePrefixedAnimationSetRoot(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<AnimationSetRoot>(buf);
}

inline bool VerifyAnimationSetRootBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<AnimationSetRoot>(nullptr);
}

inline bool VerifySizePrefixedAnimationSetRootBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<AnimationSetRoot>(nullptr);
}

inline void FinishAnimationSetRootBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<AnimationSetRoot> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedAnimationSetRootBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<AnimationSetRoot> root) {
  fbb.FinishSizePrefixed(root);
}

#endif  // FLATBUFFERS_GENERATED_ANIMATIONS_H_
